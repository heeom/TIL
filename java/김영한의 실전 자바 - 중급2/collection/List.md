# 컬렉션 프레임워크 - List

- List 추상화
    - **클라이언트 클래스는 컴파일 타임에 추상적인 것에 의존하고, 런타임에 의존 관계 주입을 통해 구현체를 주입받아 사용함으로써, 재사용성과 유연성의 이점을 얻을 수 있다.**

```java
**전략 패턴(Strategy Pattern)**
디자인 패턴 중에 가장 중요한 패턴을 하나 뽑으라고 하면 전략 패턴을 뽑을 수 있다. 전략 패턴은 알고리즘을 클
라이언트 코드의 변경 없이 쉽게 교체할 수 있다. 방금 설명한 코드가 바로 전략 패턴을 사용한 코드이다.
`MyList` 인터페이스가 바로 전략을 정의하는 인터페이스가 되고, 각각의 구현체인 `MyArrayList` ,
`MyLinkedList` 가 전략의 구체적인 구현이 된다. 그리고 전략을 클라이언트 코드( `BatchProcessor` )의 변경
없이 손쉽게 교체할 수 있다.
```


```
   ArrayList -> List (interface) -> Collection(interface)
   LinkedList -> 
```
- `Collection` 인터페이스 : `java.util` 패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나
  - 자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드가 정의되어 있다.
  - `Collection` 인터페이스는 `List` , `Set` , `Queue` 와 같은 다양한 하위 인터페이스와 함께 사용된다.

## List 인터페이스

- 중복허용
- 배열을 사용
- 동적으로 변한다.
- 인터페이스에서 제공하는 메서드
    - `clear()` : 리스트에서 모든 요소를 제거한다.
    - `indexOf(Object o)` : 리스트에서 지정된 요소의 첫 번째 인덱스를 반환한다.
    - `lastIndexOf(Object o)` : 리스트에서지정된요소의마지막인덱스를반환한다 (뒤에서부터 찾음)
    - `toArray()` : 리스트의 모든 요소를 배열로 반환한다.
    - `toArray(T[] a)` 리스트의모든요소를지정된배열로반환한다.

## **자바** ArrayList

- 배열을 사용해서 데이터를 관리한다.
- 기본 `CAPACITY` 는 10이다.( `DEFAULT_CAPACITY = 10` )
    - `CAPACITY` 를 넘어가면 배열을 50% 씩 증가한다.
        - 10 -> 15 -> 22 -> 33 -> 49로 증가한다. (최적화는 자바 버전에 따라 달라질 수 있다.)
- `System.arraycopy()` 를 사용해서 메모리 고속 복사연산을 제공한다.

## **시간 복잡도와 실제 성능**

- `ArrayList` : 메모리 고속 복사를 사용
  - 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠름
  - `CAPACITY` 를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다. 하지만 한번에50%씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을 주지는 않는다.
- `LinkedList` : 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있다
