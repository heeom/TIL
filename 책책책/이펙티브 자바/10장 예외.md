## 아이템 69. 예외는 진짜 예외 상황에서만 사용하라



- **예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.**
    - 표준적이고 쉽게 이해되는 관용구를 사용하자.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야한다.
    - 특정 상태에서만 호출할 수 있는 상태의존적(Iterator.next) 메서드를 제공하는 클래스는 상태검사(Iterator.hasNext) 메서드도 함께 제공해야한다.
    - 상태 검사 메서드 대신 올바르지 않은 상태일 때 빈 Optional 혹은 null같은 특수한 값을 반환 하는 방법도 있다.
    - 상태 검사 메서드(hasNext), Optional, 특정 값(null) 중 하나를 선택하는 지침
        - Optional 이나 특정값
            - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나, 외부 요인으로 상태가 변할 수 있다면 Optional 이나 특정값을 사용한다. (상태검사 - 상태의존적 메서드 호출 사이에 객체 상태가 변할 수 있기 때문)
            - 성능이 중요한 상황에서 상태 검사 메서드가 상태의존적 메서드의 작업 일부를 중복 수행한다면 Optional이나 특정 값 선택한다.
        - 상태 검사 메서드
            - 위 두가지 경우를 제외한 다른 모든 경우에는 상태 검사 메서드 방식을 선택하자
            - 가독성이 더 좋고, 잘못 사용했을 때 발견하기 쉽다.
            

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를 프로그래밍 오류에는 런타임 예외를 사용하라



- 자바는 문제 상황을 알리는 타입(throwable)으로 아래 세가지를 제공한다.
    - 검사예외
    - 비검사 예외
        - 런타임 예외
        - 에러

| 검사 예외 | 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 됨 |
| --- | --- |
| 비검사 예외 | 프로그램에서 잡을 필요가 없다. 비검사 예외를 잡지 않은 스레드는 오류 메세지를 뱉으며 중단된다 |
- 검사예외와 비검사 예외를 구분하는 기본 규칙
    - **호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.**
    - 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자
- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자
- 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
    - Exception, RuntimeException, Error를 상속하지 않는 throwable은 사용하지 말자

참고

| RuntimeException | Exception | Error |
| --- | --- | --- |
| Unchecked 예외 | Checked 예외 | 시스템 레벨의 오류 |
| 컴파일러가 해당 예외를 명시적으로 처리하도록 강제하지 않는다.  | 컴파일러가 개발자에게 이를 처리하도록 강제한다. 주로 프로그램 외부 요인에 의해 발생할 수 있는 예외에 해당한다. try~catch 블록 내에서 처리하거나, 메서드 선언에 throws로 호출자에 예외를 전파해야한다. | 프로그램이 복구할 수 없는 치명적인 상황에 발생한다. 일반적으로 이런 오류는 애플리케이션 코드에서 직접 처리하지 않고, 시스템에 의해 처리된다. |
| NPE, ArrayIndexOutOfBoundsException | IOException | OutOfMemoryError, StackOverFlowError |

## 아이템 71. 필요없는 검사 예외 사용은 피하라



- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주기를 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때에만 검사 예외를 던지자.

## 아이템 72. 표준예외를 사용하라



- 많이 재사용되는 표준 예외
    - IllegalArgumentException
    - IllegalStateException
        - 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을때
        - 인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException을, 그렇지 않으면 IllegalArgumentException을 던지자.
    - ConcurrentModificationException
        - 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려고 할때
    - UnsupportedOperationException
        - 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.
        - 보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없을 때 사용한다.
- **Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.**

## 아이템 73. 추상화 수준에 맞는 예외를 던지라



- **상위계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야한다.**
    - 예외 번역 (Exception translation)
    
    ```java
    try {
    } catch(LowerLevelExcpetion e) { // 저수준 추상화를 이용
    	throw new HigerLevelException(); // 추상화 수준에 맞게 번역
    }
    ```
    
- 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는게 좋다.
    - Exception Chaining이란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.
    - throwable의 getCause 메서드를 통해 저수준 예외를 꺼내 볼 수 있다.
    - 고수준 예외의 생성자는 상위 클래스의 생성자에 원인을 건내줘서 최종적으로는 Throwable 생성자까지 건네지게 된다
    
    ```java
    try {
    } catch(LowerLevelExcpetion e) { 
    	throw new HigerLevelException(e); // 저수준 예외를 고수준 예외에 실어 보낸다.
    }
    
    // 예외 연쇄용 생성자
    class HigerLevelException extends Exception {
    		HigerLevelException(Throwable cause) {
    			super(cause);
    		}
    }
    ```
    
- 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 안된다. 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.

## 아이템 74. 메서드가 던지는 모든 예외를 문서화하라



- **검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자**
- **메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의  throws 목록에 넣지 말자.**
    - checked, unchecked 에 따라 API 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분해주는 게 좋다.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다.

## 아이템 75. 예외의 상세 메세지에 실패 관련 정보를 담으라



- 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 stack trace 정보를 자동으로 출력한다. stack trace는 예외 객체의 toStrign 메서드를 호출해 얻는 문자열로, 보통은 예외의 클래스 이름 뒤에 상세 메세지가 붙는 형태이다.
- 사후 분석을 위해 실패 순간의 상황을 정확히 포착해 예외의 상세 메세지에 담아야한다.
- **실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개 변수와 필드의 값을 실패 메세지에 담아야 한다.**

## 아이템 76. 가능한 한 실패 원자적으로 만들라



- **호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야한다.**
    - 실패 원자적 특성(failure-atomic)
- failure-atomic한 방법
    - 불변 객체로 설계한다.
    - 가변 객체의 메서드라면 작업 수행 전에 매개변수의 유효성을 검사한다.
    - 객체의 임시 복사본에서 작업을 수행한다음 작업이 성공적으로 완료되면 원래 객체와 교체한다.
        - 예를 들면, 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨 담는다. 배열을 사용하면 정렬 알고리즘의 반복문에서 원소들에 훨씬 빠르게 접근 가능하고, 정렬에 실패하더라도 입력 리스트는 변하지 않는다.
    - 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법
    

## 아이템 77. 예외를 무시하지 말라



- catch 블록을 비워두면, 아무것도 하지 않으면 예외가 존재할 이유가 없어진다.
- 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓자.
    
    ```java
    try {
    } catch(ExecutionException ignored) {
    // 예외 무시하기로 한 이유
    }
    ```
