# Hash Table
## 해시 테이블

---

- key-value 형태로 키를 값에 매핑할 수 있는 자료구조
- 대부분의 연산이 시간 복잡도가 O(1)

## 해시

---

- 해시함수 : 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수
    - 입력값이 특정 함수(해시 함수)를 통과하면 고정 크기 값으로 매핑된다.
        - ABC → A1
        - 12324BC → CB
- 성능이 좋은 해시 함수들의 특징
    - 결과값 충돌의 최소화
    - 쉽고 빠른 연산
    - 해시 테이블 전체에 해시 값이 균일하게 분포
    - 사용할 키의 모든 정보를 이용하여 해싱
    - 해시 테이블 사용 효율이 높을 것

## 해시 함수

---

- 나눗셈 방식

    ```
    h(x) = x mode m
    
    1. h(x) : 입력 값 x의 해시 함수를 통해 생성된 결과
    2. m : 해시 테이블의 크기 (2의 멱수에 가깝지 않은 소수)
    3. x : 규칙을 통해 만들어낸 충분히 랜덤한 상태의 키 값
    ```


## 해시 충돌

---

### 비둘기집의 원리

- n개의 아이템을 m개의 컨테이너에 넣을 때 n > m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어있다는 원리
- 비둘기집의 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생하게 된다.

### 생일 문제

- 비둘기집의 원리에 따라 같은 생일이 존재할 경우의 수는 365 + 1일거라고 생각하지만 23명만 모여도 같은 생일이 존재할 확률 약 50퍼센트
- 생일 문제 테스트 코드

```java
        int sameBirth = 0;

// 10만번 반복
        for (int i = 1; i <= 100000; i++) {
        // 23명이 있다고 가정
            int[] birthDays = new int[23];
            for (int j = 0; j < 23; j++) {
            // 365일 중 랜덤으로 생일 생성
                int birthDay = ThreadLocalRandom.current().nextInt(1, 365 + 1);
                if (IntStream.of(birthDays).anyMatch(x -> x == birthDay)) {
	                // 23명 중에 동일한 생일이 있으면 sameBirth + 1
                    sameBirth++;
                    break;
                }
                // 동일한 생일이 없으면 저장하고 다음 진행
                birthDays[j] = birthDay;
            }
        }

        System.out.println("percent of sameBirth : " +  (double) sameBirth / 100000 * 100);
    }
```

```
percent of sameBirth : 50.786
```

⇒ 충돌은 생각보다 쉽게 발생 하므로 충돌을 최소화하는 것이 중요하다

여러번 충돌한다는 것은 그만큼 추가 연산이 필요하기 때문에 가급적 충돌은 최소화하는 것이 좋다.

## 충돌 최소화

---

- 충돌 발생 전 최적화를 해야하는데 이 결정을 로드 팩터라고 한다
    - 해시함수를 재작성할 것인지
    - 해시테이블의 크기를 조정할 것인지
- 로드 팩터 = n / k
    - n : 해시 테이블에 저장된 데이터 개수
    - k :  버킷의 개수
    - 로드 팩터는 해시함수가 키들을 잘 분산해주는 지 말해주는 효율성 측정에도 사용된다.
    - Java 8에서 기본 로드 팩터는 0.75
        - 로드 팩터가 여기서 더 높아지면 해시테이블의 성능은 낮아지므로, 동적 배열처럼 해시 테이블 공간을 재할당한다.

## 충돌 발생

---

### 개별 체이닝 (Separate Chaining)

- 충돌 발생 시 연결리스트로 연결
- 최악의 경우 탐색은 O(n)
    - Java8의 해시 테이블 구현체인 HashMap은 연결 리스트 구조를 좀 더 최적화해서, 데이터의 개수가 많아지면 레드-블랙 트리에 저장하는 형태를 병행한다.

### 오픈 어드레싱 (Open Addressing)

- 충돌이 발생하면 테이블 공간 내에서 빈공간을 찾아 해결한다
- 무한정 저장할 수 있는 개별 체이닝 방식과 달리 전체 슬롯 개수 이상은 저장할 수 없다.
- 가장 간단한 방식인 선형 탐사(Linear Probing) 방식의 경우
    - 충돌 발생 → 해당 위치부터 순차적으로 탐사를 하나씩 진행
    - 특정 위치가 선점되어 있으면 그 다음 위치 확인
    - 비어있는 공간을 발견하면 삽입한다.
    - 즉 가장 가까운 다음 빈 위치를 탐사해서 새 키를 삽입하는 방식
- 문제점
    - 해시 테이블에 저장되는 데이터의 분포가 고르지 않고 한군데에 치우치는 경향이 있다.
- 버킷 크기보다 큰 경우에는 삽입 불가능 → 일정 이상 채워지면 (로드 팩터 비율을 넘어서면) 그로스 팩터의 비율에 따라 더 큰 크기(해시맵의 경우 2배)의 또다른 버킷을 생성한 후에 값을 복사하는 Rehashing 작업이 발생한다.

- java, go, c++ → 개별 체이닝
- python → 오픈 어드레싱

